what happens inside tokio 

#[tokio::main]
async fn main() {
    hello().await;
}

async fn hello() {
    println!("Hello, async world!");
}

is replaced with 

fn main() {
    tokio::runtime::Builder::new_multi_thread(). // uses a builder pattern
        .enable_all()
        .build() 
        .unwrap()
        .block_on(tokio_main());
}

// block_on : block the main thread until the async is excecuted 
//  .build()  say you have 8 CPU 8 thread
async fn tokio_main() {
    hello().await;
}


async fn hello() {
    println!("Hello, async world!");
}

what really happens in async ? 


// Future is a trait, which comes with async 

what actually happens in await ? 
// a state machine is implemented 
enum TokioMainState {
    Start,
    AwaitingHello,
    Done,
}
// pining is a concept that u dont lose the memory when async is executed 


hand-written version of what Rust’s async/await
What it does

Runs a tiny async program on a single-thread Tokio runtime.
tokio_main() “awaits” hello(), and hello() “awaits” print_async().
print_async() prints: “Hello, async world!”
How it works (simple mental model)

Each async function is represented as a struct + enum state machine:
TokioMainFuture with states Start -> AwaitingHello -> Done
HelloFuture with states Start -> AwaitingPrint -> Done
Calling poll() is like saying: “Do a bit of work now; tell me if you’re done.”
Return Poll::Ready(()) => finished
Return Poll::Pending => not finished yet, try later
Step-by-step flow

Runtime calls tokio_main future’s poll.
In Start, it creates hello() future, moves to AwaitingHello.
In AwaitingHello, it polls hello().
hello() does the same with print_async().
print_async() prints once and returns Ready.
Then hello() returns Ready, then tokio_main() returns Ready.
Why Pin and unsafe appear

Futures may contain self-references internally, so they must not be moved once polled.
poll() requires Pin<&mut Self>.
Pin::new_unchecked(...) is used here manually to pin inner futures; this is educational but advanced.
In real code, async/await usually avoids writing this unsafe machinery yourself.
If you want, I can also show the equivalent normal version using plain async fn + .await so you can compare line-by-line.


// 
waker
 it decides what needs to be woken up 
 Vtable : dyn is a table with the object types and object memeory 

// when state function is high which is when u add more await in one function 


// #[tokio::main(flavor = "current_thread")]

to put in one thread 

// tokio file system are not very much handled in tokio 

//spawn_blocking means: put blocking/synchronous work on a separate thread pool so your async tasks keep running. 

to add tokio full 
cargo add tokio -F full

// to run somethign on background
tokio::spawn starts an async task in the background on Tokio’s runtime.

// from_utf8_lossy 
stream of byte not neccassry a valid byte 


// Channels
“Do not communicate by sharing memory; instead, share memory by communicating.” - Rob Pike


multiple thread , and program to quit, static varaible to quit 
and thread is referening to quit

mutex pattern learn ..

// no cleanup is needed in mpsc channel is because tx and rx impements drop trait 
let (tx, mut rx) = mpsc::channel(32);

